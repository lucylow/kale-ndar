import { Keypair } from '@stellar/stellar-sdk';
import { SorobanClient } from '@stellar/soroban-client';
import { StellarRpcService } from './stellar-rpc.service';
import { KaleTokenService } from './kale-token.service';
import { MarketCreationService } from './market-creation.service';
import { OracleService } from './oracle.service';
import { logger } from '../utils/logger';
import Big from 'big.js';
import * as cron from 'node-cron';

export interface DynamicMarketTemplate {
  id: string;
  name: string;
  description: string;
  assetSymbol: string;
  condition: 'above' | 'below';
  thresholdType: 'price' | 'percentage' | 'volume' | 'time';
  thresholdValue: string;
  timeframe: 'hourly' | 'daily' | 'weekly' | 'monthly';
  isActive: boolean;
  createdAt: number;
  lastGenerated?: number;
  generationCount: number;
  oracleSubscriptionId?: string;
}

export interface AutoGeneratedMarket {
  id: string;
  templateId: string;
  name: string;
  description: string;
  assetSymbol: string;
  targetPrice: string;
  condition: 'above' | 'below';
  resolveTime: number;
  createdAt: number;
  generatedBy: 'oracle' | 'cron' | 'manual';
  triggerData?: any;
}

export interface MarketGenerationRule {
  id: string;
  templateId: string;
  ruleType: 'price_threshold' | 'time_interval' | 'volume_spike' | 'volatility';
  condition: any;
  isActive: boolean;
  lastTriggered?: number;
  triggerCount: number;
}

export class DynamicMarketsService {
  private stellarRpc: StellarRpcService;
  private kaleToken: KaleTokenService;
  private marketService: MarketCreationService;
  private oracleService: OracleService;
  private kaleIntegrationContractId: string;
  private templates: Map<string, DynamicMarketTemplate> = new Map();
  private generationRules: Map<string, MarketGenerationRule[]> = new Map();
  private cronJobs: Map<string, cron.ScheduledTask> = new Map();

  constructor(
    stellarRpc: StellarRpcService,
    kaleToken: KaleTokenService,
    marketService: MarketCreationService,
    oracleService: OracleService,
    kaleIntegrationContractId: string
  ) {
    this.stellarRpc = stellarRpc;
    this.kaleToken = kaleToken;
    this.marketService = marketService;
    this.oracleService = oracleService;
    this.kaleIntegrationContractId = kaleIntegrationContractId;
    
    this.initializeDefaultTemplates();
    this.startCronJobs();
  }

  /**
   * Create a new dynamic market template
   */
  async createMarketTemplate(
    creatorKeypair: Keypair,
    template: Omit<DynamicMarketTemplate, 'id' | 'createdAt' | 'generationCount'>
  ): Promise<DynamicMarketTemplate> {
    try {
      const templateId = `template_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      
      const marketTemplate: DynamicMarketTemplate = {
        id: templateId,
        ...template,
        createdAt: Date.now(),
        generationCount: 0,
      };

      // Store template
      this.templates.set(templateId, marketTemplate);

      // Create oracle subscription if needed
      if (template.thresholdType === 'price' || template.thresholdType === 'percentage') {
        const subscription = await this.oracleService.createPriceFeedSubscription(
          templateId, // Use template ID as market ID for oracle
          template.assetSymbol,
          'USD',
          100, // 1% threshold
          60   // 60 min heartbeat
        );
        
        marketTemplate.oracleSubscriptionId = subscription.id;
      }

      // Create generation rules
      await this.createGenerationRules(templateId, template);

      // Start cron job if time-based
      if (template.timeframe !== 'manual') {
        this.startTemplateCronJob(templateId);
      }

      logger.info('Dynamic market template created:', {
        templateId,
        name: template.name,
        assetSymbol: template.assetSymbol,
        timeframe: template.timeframe,
        thresholdType: template.thresholdType,
      });

      return marketTemplate;
    } catch (error) {
      logger.error('Failed to create market template:', error);
      throw error;
    }
  }

  /**
   * Generate market from template
   */
  async generateMarketFromTemplate(
    templateId: string,
    triggerData?: any
  ): Promise<AutoGeneratedMarket> {
    try {
      const template = this.templates.get(templateId);
      if (!template || !template.isActive) {
        throw new Error('Template not found or inactive');
      }

      // Calculate target price and resolve time
      const { targetPrice, resolveTime } = await this.calculateMarketParameters(template, triggerData);

      // Create market
      const creatorKeypair = Keypair.fromSecret(process.env.SYSTEM_SECRET || '');
      const marketRequest = {
        creator: creatorKeypair.publicKey(),
        description: this.generateMarketDescription(template, targetPrice, resolveTime),
        assetSymbol: template.assetSymbol,
        targetPrice: targetPrice.toString(),
        condition: template.condition,
        resolveTime,
        marketFee: '100', // Default fee
      };

      const market = await this.marketService.createMarket(creatorKeypair, marketRequest);

      // Create auto-generated market record
      const autoMarket: AutoGeneratedMarket = {
        id: market.id,
        templateId,
        name: template.name,
        description: marketRequest.description,
        assetSymbol: template.assetSymbol,
        targetPrice: targetPrice.toString(),
        condition: template.condition,
        resolveTime,
        createdAt: Date.now(),
        generatedBy: triggerData ? 'oracle' : 'cron',
        triggerData,
      };

      // Update template stats
      template.generationCount += 1;
      template.lastGenerated = Date.now();
      this.templates.set(templateId, template);

      // Store auto-generated market
      await this.storeAutoGeneratedMarket(autoMarket);

      logger.info('Market generated from template:', {
        templateId,
        marketId: market.id,
        targetPrice: targetPrice.toString(),
        resolveTime,
        generatedBy: autoMarket.generatedBy,
      });

      return autoMarket;
    } catch (error) {
      logger.error('Failed to generate market from template:', error);
      throw error;
    }
  }

  /**
   * Handle oracle trigger for market generation
   */
  async handleOracleTrigger(
    subscriptionId: string,
    oracleData: any
  ): Promise<AutoGeneratedMarket | null> {
    try {
      // Find template by oracle subscription ID
      const template = Array.from(this.templates.values())
        .find(t => t.oracleSubscriptionId === subscriptionId);

      if (!template) {
        logger.warn('No template found for oracle subscription:', subscriptionId);
        return null;
      }

      // Check if trigger conditions are met
      const shouldGenerate = await this.checkTriggerConditions(template, oracleData);
      
      if (!shouldGenerate) {
        return null;
      }

      // Generate market
      return await this.generateMarketFromTemplate(template.id, oracleData);
    } catch (error) {
      logger.error('Failed to handle oracle trigger:', error);
      return null;
    }
  }

  /**
   * Get all market templates
   */
  async getMarketTemplates(): Promise<DynamicMarketTemplate[]> {
    return Array.from(this.templates.values());
  }

  /**
   * Get auto-generated markets
   */
  async getAutoGeneratedMarkets(
    templateId?: string,
    limit: number = 50
  ): Promise<AutoGeneratedMarket[]> {
    try {
      // This would typically query database
      // For now, returning mock data
      return [];
    } catch (error) {
      logger.error('Failed to get auto-generated markets:', error);
      throw error;
    }
  }

  /**
   * Update template
   */
  async updateTemplate(
    templateId: string,
    updates: Partial<DynamicMarketTemplate>
  ): Promise<void> {
    try {
      const template = this.templates.get(templateId);
      if (!template) {
        throw new Error('Template not found');
      }

      const updatedTemplate = { ...template, ...updates };
      this.templates.set(templateId, updatedTemplate);

      logger.info('Template updated:', { templateId, updates });
    } catch (error) {
      logger.error('Failed to update template:', error);
      throw error;
    }
  }

  /**
   * Delete template
   */
  async deleteTemplate(templateId: string): Promise<void> {
    try {
      const template = this.templates.get(templateId);
      if (!template) {
        throw new Error('Template not found');
      }

      // Stop cron job
      const cronJob = this.cronJobs.get(templateId);
      if (cronJob) {
        cronJob.stop();
        this.cronJobs.delete(templateId);
      }

      // Cancel oracle subscription
      if (template.oracleSubscriptionId) {
        await this.oracleService.cancelSubscription(template.oracleSubscriptionId);
      }

      // Remove template
      this.templates.delete(templateId);
      this.generationRules.delete(templateId);

      logger.info('Template deleted:', { templateId });
    } catch (error) {
      logger.error('Failed to delete template:', error);
      throw error;
    }
  }

  /**
   * Initialize default templates
   */
  private initializeDefaultTemplates(): void {
    const defaultTemplates: Omit<DynamicMarketTemplate, 'id' | 'createdAt' | 'generationCount'>[] = [
      {
        name: 'BTC Daily Price Target',
        description: 'Will BTC reach a new daily high?',
        assetSymbol: 'BTC',
        condition: 'above',
        thresholdType: 'price',
        thresholdValue: '0', // Will be calculated dynamically
        timeframe: 'daily',
        isActive: true,
      },
      {
        name: 'ETH Weekly Volatility',
        description: 'Will ETH experience high volatility this week?',
        assetSymbol: 'ETH',
        condition: 'above',
        thresholdType: 'percentage',
        thresholdValue: '10', // 10% change
        timeframe: 'weekly',
        isActive: true,
      },
      {
        name: 'Crypto Market Cap',
        description: 'Will total crypto market cap exceed $3T?',
        assetSymbol: 'CRYPTO',
        condition: 'above',
        thresholdType: 'price',
        thresholdValue: '3000000000000',
        timeframe: 'monthly',
        isActive: true,
      },
    ];

    defaultTemplates.forEach(async (template) => {
      try {
        const creatorKeypair = Keypair.fromSecret(process.env.SYSTEM_SECRET || '');
        await this.createMarketTemplate(creatorKeypair, template);
      } catch (error) {
        logger.error('Failed to create default template:', error);
      }
    });
  }

  /**
   * Start cron jobs for time-based templates
   */
  private startCronJobs(): void {
    // Daily market generation at 9 AM UTC
    cron.schedule('0 9 * * *', async () => {
      await this.generateDailyMarkets();
    });

    // Weekly market generation on Mondays at 10 AM UTC
    cron.schedule('0 10 * * 1', async () => {
      await this.generateWeeklyMarkets();
    });

    // Monthly market generation on 1st at 11 AM UTC
    cron.schedule('0 11 1 * *', async () => {
      await this.generateMonthlyMarkets();
    });

    logger.info('Dynamic markets cron jobs started');
  }

  /**
   * Start cron job for specific template
   */
  private startTemplateCronJob(templateId: string): void {
    const template = this.templates.get(templateId);
    if (!template) return;

    let cronExpression: string;
    switch (template.timeframe) {
      case 'hourly':
        cronExpression = '0 * * * *'; // Every hour
        break;
      case 'daily':
        cronExpression = '0 9 * * *'; // Daily at 9 AM
        break;
      case 'weekly':
        cronExpression = '0 10 * * 1'; // Weekly on Monday at 10 AM
        break;
      case 'monthly':
        cronExpression = '0 11 1 * *'; // Monthly on 1st at 11 AM
        break;
      default:
        return;
    }

    const cronJob = cron.schedule(cronExpression, async () => {
      try {
        await this.generateMarketFromTemplate(templateId);
      } catch (error) {
        logger.error('Failed to generate market from cron job:', error);
      }
    });

    this.cronJobs.set(templateId, cronJob);
  }

  /**
   * Generate daily markets
   */
  private async generateDailyMarkets(): Promise<void> {
    const dailyTemplates = Array.from(this.templates.values())
      .filter(t => t.timeframe === 'daily' && t.isActive);

    for (const template of dailyTemplates) {
      try {
        await this.generateMarketFromTemplate(template.id);
      } catch (error) {
        logger.error('Failed to generate daily market:', error);
      }
    }
  }

  /**
   * Generate weekly markets
   */
  private async generateWeeklyMarkets(): Promise<void> {
    const weeklyTemplates = Array.from(this.templates.values())
      .filter(t => t.timeframe === 'weekly' && t.isActive);

    for (const template of weeklyTemplates) {
      try {
        await this.generateMarketFromTemplate(template.id);
      } catch (error) {
        logger.error('Failed to generate weekly market:', error);
      }
    }
  }

  /**
   * Generate monthly markets
   */
  private async generateMonthlyMarkets(): Promise<void> {
    const monthlyTemplates = Array.from(this.templates.values())
      .filter(t => t.timeframe === 'monthly' && t.isActive);

    for (const template of monthlyTemplates) {
      try {
        await this.generateMarketFromTemplate(template.id);
      } catch (error) {
        logger.error('Failed to generate monthly market:', error);
      }
    }
  }

  /**
   * Calculate market parameters
   */
  private async calculateMarketParameters(
    template: DynamicMarketTemplate,
    triggerData?: any
  ): Promise<{ targetPrice: Big; resolveTime: number }> {
    try {
      let targetPrice: Big;
      let resolveTime: number;

      // Get current price
      const currentPrice = await this.oracleService.getCurrentPrice(template.assetSymbol, 'USD');
      const price = new Big(currentPrice?.price || '0');

      // Calculate target price based on threshold type
      switch (template.thresholdType) {
        case 'price':
          targetPrice = new Big(template.thresholdValue);
          break;
        case 'percentage':
          const percentage = new Big(template.thresholdValue).div(100);
          targetPrice = price.mul(percentage.add(1));
          break;
        case 'volume':
          // Volume-based targets would need additional data
          targetPrice = price.mul(1.1); // 10% above current price
          break;
        default:
          targetPrice = price.mul(1.05); // 5% above current price
      }

      // Calculate resolve time based on timeframe
      const now = Date.now();
      switch (template.timeframe) {
        case 'hourly':
          resolveTime = now + (60 * 60 * 1000); // 1 hour
          break;
        case 'daily':
          resolveTime = now + (24 * 60 * 60 * 1000); // 24 hours
          break;
        case 'weekly':
          resolveTime = now + (7 * 24 * 60 * 60 * 1000); // 7 days
          break;
        case 'monthly':
          resolveTime = now + (30 * 24 * 60 * 60 * 1000); // 30 days
          break;
        default:
          resolveTime = now + (24 * 60 * 60 * 1000); // Default to 24 hours
      }

      return { targetPrice, resolveTime };
    } catch (error) {
      logger.error('Failed to calculate market parameters:', error);
      throw error;
    }
  }

  /**
   * Generate market description
   */
  private generateMarketDescription(
    template: DynamicMarketTemplate,
    targetPrice: Big,
    resolveTime: number
  ): string {
    const resolveDate = new Date(resolveTime).toLocaleDateString();
    const conditionText = template.condition === 'above' ? 'exceed' : 'fall below';
    
    return `Will ${template.assetSymbol} ${conditionText} $${targetPrice.toFixed(2)} by ${resolveDate}?`;
  }

  /**
   * Create generation rules
   */
  private async createGenerationRules(
    templateId: string,
    template: DynamicMarketTemplate
  ): Promise<void> {
    const rules: MarketGenerationRule[] = [];

    // Price threshold rule
    if (template.thresholdType === 'price' || template.thresholdType === 'percentage') {
      rules.push({
        id: `rule_${templateId}_price`,
        templateId,
        ruleType: 'price_threshold',
        condition: {
          threshold: template.thresholdValue,
          thresholdType: template.thresholdType,
        },
        isActive: true,
        triggerCount: 0,
      });
    }

    // Time interval rule
    if (template.timeframe !== 'manual') {
      rules.push({
        id: `rule_${templateId}_time`,
        templateId,
        ruleType: 'time_interval',
        condition: {
          interval: template.timeframe,
        },
        isActive: true,
        triggerCount: 0,
      });
    }

    this.generationRules.set(templateId, rules);
  }

  /**
   * Check trigger conditions
   */
  private async checkTriggerConditions(
    template: DynamicMarketTemplate,
    oracleData: any
  ): Promise<boolean> {
    try {
      const rules = this.generationRules.get(template.id) || [];
      
      for (const rule of rules) {
        if (!rule.isActive) continue;

        switch (rule.ruleType) {
          case 'price_threshold':
            if (await this.checkPriceThreshold(rule, oracleData)) {
              return true;
            }
            break;
          case 'volatility':
            if (await this.checkVolatility(rule, oracleData)) {
              return true;
            }
            break;
        }
      }

      return false;
    } catch (error) {
      logger.error('Failed to check trigger conditions:', error);
      return false;
    }
  }

  /**
   * Check price threshold condition
   */
  private async checkPriceThreshold(
    rule: MarketGenerationRule,
    oracleData: any
  ): Promise<boolean> {
    const currentPrice = new Big(oracleData.price || '0');
    const threshold = new Big(rule.condition.threshold);
    
    if (rule.condition.thresholdType === 'percentage') {
      const percentage = threshold.div(100);
      const targetPrice = currentPrice.mul(percentage.add(1));
      return currentPrice.gte(targetPrice);
    } else {
      return currentPrice.gte(threshold);
    }
  }

  /**
   * Check volatility condition
   */
  private async checkVolatility(
    rule: MarketGenerationRule,
    oracleData: any
  ): Promise<boolean> {
    // This would check for volatility spikes
    // For now, returning false
    return false;
  }

  /**
   * Store auto-generated market
   */
  private async storeAutoGeneratedMarket(market: AutoGeneratedMarket): Promise<void> {
    // This would typically store in database
    logger.info('Auto-generated market stored:', market);
  }
}

